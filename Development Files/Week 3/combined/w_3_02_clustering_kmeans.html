<!-- Skip link for keyboard users -->
<a href="#main-content" class="sr-only sr-only-focusable">Skip to main content</a>

<main id="main-content" role="main">
<div id="dp-wrapper" class="dp-wrapper">
  <div class="dp-progress-placeholder dp-module-progress-icons" style="display: none;" aria-hidden="true">Icon Progress Bar (browser only)</div>

  <div class="dp-content-block content-block" data-title="K-means Clustering Algorithm">
    <h2 class="dp-has-icon"><i class="dp-icon fas fa-layer-group" aria-hidden="true"></i>&nbsp;K-means Clustering</h2>
    <div class="dp-card card" style="border-left: 4px solid #034638; padding-left: 15px;">
      <div class="card-body">
        <h3 class="card-title dp-ignore-theme">What this page covers</h3>
        <p>Master the most popular clustering algorithm: how K-means works, when to use it, choosing the right K, and understanding its strengths and limitations for business applications.</p>
      </div>
    </div>
  </div>


  <div class="dp-content-block content-block" data-title="How K-means Works">
    <h2 class="dp-has-icon"><i class="dp-icon fas fa-cogs" aria-hidden="true"></i>&nbsp;The K-means Algorithm</h2>
    <div class="dp-panels-wrapper dp-accordion-default dp-panel-hover-color-dp-white dp-panel-active-color-dark">
      <div class="dp-panel-group">
        <h3 class="dp-panel-heading" role="button" tabindex="0" aria-expanded="false" aria-controls="algorithm-steps" id="algorithm-steps-heading">Step-by-Step Process</h3>
        <div id="algorithm-steps" class="dp-panel-content" role="region" aria-labelledby="algorithm-steps-heading" hidden>
          <p>K-means is an iterative algorithm that partitions data into K clusters by minimizing within-cluster sum of squares.</p>
          <div class="table-responsive">
            <table class="ic-Table ic-Table--hover-row" role="table" aria-label="K-means algorithm steps">
              <caption>K-means Algorithm Steps and Their Purpose</caption>
              <thead>
                <tr>
                  <th scope="col">Step</th>
                  <th scope="col">Action</th>
                  <th scope="col">Purpose</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <th scope="row">1. Initialize</th>
                  <td>Randomly place K centroids</td>
                  <td>Starting positions for cluster centers</td>
                </tr>
                <tr>
                  <th scope="row">2. Assign</th>
                  <td>Assign each point to nearest centroid</td>
                  <td>Form clusters based on distance</td>
                </tr>
                <tr>
                  <th scope="row">3. Update</th>
                  <td>Move centroids to cluster means</td>
                  <td>Optimize cluster center positions</td>
                </tr>
                <tr>
                  <th scope="row">4. Repeat</th>
                  <td>Repeat steps 2-3 until convergence</td>
                  <td>Minimize within-cluster variance</td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>
      </div>
      <div class="dp-panel-group">
        <h3 class="dp-panel-heading" role="button" tabindex="0" aria-expanded="false" aria-controls="convergence" id="convergence-heading">Convergence and Stopping Criteria</h3>
        <div id="convergence" class="dp-panel-content" role="region" aria-labelledby="convergence-heading" hidden>
          <p>K-means stops when clusters stabilize. Multiple stopping criteria ensure practical convergence:</p>
          <ul class="list-group list-group-flush">
            <li class="list-group-item"><strong>No reassignments</strong>: Points stay in same clusters between iterations</li>
            <li class="list-group-item"><strong>Centroid stability</strong>: Centroids move less than threshold distance</li>
            <li class="list-group-item"><strong>Maximum iterations</strong>: Prevent infinite loops (typically 100-300)</li>
            <li class="list-group-item"><strong>Objective function</strong>: Within-cluster sum of squares stops decreasing</li>
          </ul>
        </div>
      </div>
      <div class="dp-panel-group">
        <h3 class="dp-panel-heading" role="button" tabindex="0" aria-expanded="false" aria-controls="distance-measures" id="distance-measures-heading">Distance Measures and Scaling</h3>
        <div id="distance-measures" class="dp-panel-content" role="region" aria-labelledby="distance-measures-heading" hidden>
          <div class="row">
            <div class="col-md-6">
              <div class="dp-card card" style="background-color:#f8f9fa; border:1px solid #dee2e6;">
                <div class="card-body">
                  <h4 class="card-title">Standard Distance: Euclidean</h4>
                  <p>Most common: straight-line distance in feature space</p>
                  <p class="mb-0"><code>√[(x₁-x₂)² + (y₁-y₂)²]</code></p>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="dp-card card" style="background-color:#fff3cd; border:1px solid #ffeaa7;">
                <div class="card-body">
                  <h4 class="card-title">Critical: Feature Scaling</h4>
                  <p>Always normalize features to same scale</p>
                  <p class="mb-0">Otherwise: large-scale features dominate</p>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="dp-content-block content-block" data-title="Choosing the Number of Clusters (K)">
    <h2 class="dp-has-icon"><i class="dp-icon fas fa-chart-line" aria-hidden="true"></i>&nbsp;Selecting Optimal K</h2>
    <div class="dp-panels-wrapper dp-accordion-default dp-panel-hover-color-dp-white">
      <div class="dp-panel-group">
        <h3 class="dp-panel-heading" role="button" tabindex="0" aria-expanded="false" aria-controls="elbow-method" id="elbow-method-heading">The Elbow Method</h3>
        <div id="elbow-method" class="dp-panel-content" role="region" aria-labelledby="elbow-method-heading" hidden>
          <div class="row">
            <div class="col-md-8">
              <p>Plot within-cluster sum of squares (WCSS) vs number of clusters. Look for the "elbow" - the point where adding clusters provides diminishing returns.</p>
              <ul class="list-group list-group-flush">
                <li class="list-group-item"><strong>Sharp elbow</strong>: Clear optimal K</li>
                <li class="list-group-item"><strong>Gradual curve</strong>: Consider business context</li>
                <li class="list-group-item"><strong>No clear elbow</strong>: Try other methods</li>
              </ul>
            </div>
            <div class="col-md-4">
              <div class="dp-card card" style="background-color:#e7f3ff; border:1px solid #b3d9ff;">
                <div class="card-body">
                  <h4 class="card-title">Formula</h4>
                  <p>WCSS = Σ(distance from point to centroid)²</p>
                  <p class="mb-0">Lower WCSS = tighter clusters</p>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
      <div class="dp-panel-group">
        <h3 class="dp-panel-heading" role="button" tabindex="0" aria-expanded="false" aria-controls="silhouette" id="silhouette-heading">Silhouette Analysis</h3>
        <div id="silhouette" class="dp-panel-content" role="region" aria-labelledby="silhouette-heading" hidden>
          <p>Measures how well each point fits its assigned cluster compared to other clusters. Ranges from -1 to +1.</p>
          <div class="table-responsive">
            <table class="ic-Table ic-Table--hover-row" role="table" aria-label="Silhouette score interpretation">
              <caption>Silhouette Score Ranges and Recommended Actions</caption>
              <thead>
                <tr>
                  <th scope="col">Silhouette Score</th>
                  <th scope="col">Interpretation</th>
                  <th scope="col">Action</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <th scope="row">0.7 - 1.0</th>
                  <td>Excellent cluster separation</td>
                  <td>Strong clustering solution</td>
                </tr>
                <tr>
                  <th scope="row">0.5 - 0.7</th>
                  <td>Reasonable clustering</td>
                  <td>Acceptable for most uses</td>
                </tr>
                <tr>
                  <th scope="row">0.25 - 0.5</th>
                  <td>Weak clustering structure</td>
                  <td>Consider different K or method</td>
                </tr>
                <tr>
                  <th scope="row">&lt; 0.25</th>
                  <td>No meaningful clusters</td>
                  <td>Clustering may not be appropriate</td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>
      </div>
      <div class="dp-panel-group">
        <h3 class="dp-panel-heading" role="button" tabindex="0" aria-expanded="false" aria-controls="business-context" id="business-context-heading">Business Context and Domain Knowledge</h3>
        <div id="business-context" class="dp-panel-content" role="region" aria-labelledby="business-context-heading" hidden>
          <p>Mathematical metrics are valuable, but business context should guide final decisions.</p>
          <ul class="list-group list-group-flush">
            <li class="list-group-item"><strong>Customer segments</strong>: Consider marketing team's capacity</li>
            <li class="list-group-item"><strong>Product categories</strong>: Align with existing taxonomy</li>
            <li class="list-group-item"><strong>Resource constraints</strong>: More clusters = more complexity</li>
            <li class="list-group-item"><strong>Interpretability</strong>: Ensure clusters have business meaning</li>
          </ul>
        </div>
      </div>
    </div>
  </div>

  <div class="dp-content-block content-block" data-title="K-means Strengths and Limitations">
    <h2 class="dp-has-icon"><i class="dp-icon fas fa-balance-scale" aria-hidden="true"></i>&nbsp;When to Use K-means</h2>
    <div class="dp-panels-wrapper dp-accordion-default dp-panel-hover-color-dp-white">
      <div class="dp-panel-group">
        <h3 class="dp-panel-heading" role="button" tabindex="0" aria-expanded="false" aria-controls="strengths" id="strengths-heading">K-means Strengths</h3>
        <div id="strengths" class="dp-panel-content" role="region" aria-labelledby="strengths-heading" hidden>
          <div class="row">
            <div class="col-md-6">
              <div class="dp-card card h-100" style="border-left: 4px solid #34d399; padding-left: 12px;">
                <div class="card-body">
                  <h4 class="card-title">Computational Advantages</h4>
                  <ul class="list-group list-group-flush">
                    <li class="list-group-item">Fast and scalable</li>
                    <li class="list-group-item">Simple to implement</li>
                    <li class="list-group-item">Memory efficient</li>
                  </ul>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="dp-card card h-100" style="border-left: 4px solid #3b82f6; padding-left: 12px;">
                <div class="card-body">
                  <h4 class="card-title">Practical Benefits</h4>
                  <ul class="list-group list-group-flush">
                    <li class="list-group-item">Well-understood algorithm</li>
                    <li class="list-group-item">Deterministic results</li>
                    <li class="list-group-item">Works with any distance metric</li>
                  </ul>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
      <div class="dp-panel-group">
        <h3 class="dp-panel-heading" role="button" tabindex="0" aria-expanded="false" aria-controls="limitations" id="limitations-heading">Important Limitations</h3>
        <div id="limitations" class="dp-panel-content" role="region" aria-labelledby="limitations-heading" hidden>
          <div class="dp-card card" style="border-left: 4px solid #dc2626; padding-left: 12px;">
            <div class="card-body">
              <h4 class="card-title">When K-means Struggles</h4>
              <ul class="list-group list-group-flush">
                <li class="list-group-item"><strong>Non-spherical clusters</strong>: Assumes circular/spherical cluster shapes</li>
                <li class="list-group-item"><strong>Different cluster sizes</strong>: Prefers evenly-sized clusters</li>
                <li class="list-group-item"><strong>Different densities</strong>: Can't handle varying cluster densities</li>
                <li class="list-group-item"><strong>Outliers</strong>: Sensitive to extreme values</li>
                <li class="list-group-item"><strong>Initialization</strong>: Different starting points can yield different results</li>
              </ul>
            </div>
          </div>
        </div>
      </div>
      <div class="dp-panel-group">
        <h3 class="dp-panel-heading" role="button" tabindex="0" aria-expanded="false" aria-controls="alternatives" id="alternatives-heading">Alternative Clustering Methods</h3>
        <div id="alternatives" class="dp-panel-content" role="region" aria-labelledby="alternatives-heading" hidden>
          <p>When K-means isn't suitable, consider these alternatives:</p>
          <div class="row">
            <div class="col-md-6">
              <div class="dp-card card h-100">
                <div class="card-body">
                  <h4 class="card-title">Hierarchical Clustering</h4>
                  <p>Creates tree of clusters. No need to specify K in advance. Good for exploring data structure.</p>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="dp-card card h-100">
                <div class="card-body">
                  <h4 class="card-title">DBSCAN</h4>
                  <p>Finds clusters of any shape. Handles outliers well. Density-based approach.</p>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="dp-content-block content-block" data-title="Interactive: K-means Clustering">
    <h2 class="dp-has-icon"><i class="dp-icon fas fa-play-circle" aria-hidden="true"></i>&nbsp;Interactive: K-means Clustering</h2>
    <p class="mt-2"><em>Explore:</em> Watch K-means find customer segments in action. Adjust K and see how clustering changes.</p>

    <div class="embedded-widget">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">

        <style>
            .embedded-widget {
                margin: 20px 0;
                border: 1px solid #e5e7eb;
                border-radius: 8px;
                overflow: hidden;
            }

            .embedded-widget .dp-wrapper {
                max-width: 800px;
                margin: 0 auto;
                padding: 20px;
                font-family: 'Figtree', system-ui, -apple-system, sans-serif;
                line-height: 1.6;
                color: #2c3e50;
                background: #fff;
            }

            .embedded-widget .dp-content-block {
                margin-bottom: 2rem;
            }

            .embedded-widget .dp-has-icon {
                display: flex;
                align-items: center;
                gap: 0.5rem;
                color: #034638;
                margin: 0 0 1rem 0;
                font-size: 1.5rem;
                font-weight: 600;
            }

            .embedded-widget .dp-card {
                background: white;
                border-radius: 8px;
                padding: 1.5rem;
                box-shadow: 0 2px 8px rgba(0,0,0,0.1);
                margin: 1rem 0;
            }

            .embedded-widget .dp-card.intro-card {
                border-left: 4px solid #034638;
                background: #f8fffe;
            }

            .embedded-widget .controls-section {
                background: #f8fffe;
                border-radius: 8px;
                padding: 1.5rem;
                margin: 1.5rem 0;
                border-left: 4px solid #034638;
            }

            .embedded-widget .controls-section h3 {
                color: #034638;
                margin: 0 0 1rem 0;
                font-weight: 600;
                display: flex;
                align-items: center;
                gap: 0.5rem;
            }

            .embedded-widget .control-group {
                margin: 1.5rem 0;
            }

            .embedded-widget .control-group label {
                font-weight: 600;
                display: block;
                margin-bottom: 0.75rem;
                color: #2c3e50;
                font-size: 0.9rem;
            }

            .embedded-widget .slider-container {
                display: flex;
                align-items: center;
                gap: 0.75rem;
                margin: 0.75rem 0;
            }

            .embedded-widget .slider-container input[type="range"] {
                flex: 1;
                height: 4px;
                background: #e5e7eb;
                border-radius: 2px;
                outline: none;
                -webkit-appearance: none;
            }

            .embedded-widget .slider-container input[type="range"]::-webkit-slider-thumb {
                -webkit-appearance: none;
                width: 16px;
                height: 16px;
                background: #034638;
                border-radius: 50%;
                cursor: pointer;
            }

            .embedded-widget .value-display {
                background: #034638;
                color: white;
                padding: 0.25rem 0.75rem;
                border-radius: 4px;
                font-weight: 600;
                font-size: 0.8rem;
                min-width: 50px;
                text-align: center;
            }

            .embedded-widget .button-group {
                display: flex;
                gap: 0.75rem;
                margin: 1.5rem 0;
                flex-wrap: wrap;
            }

            .embedded-widget .btn {
                padding: 0.75rem 1.5rem;
                border: none;
                border-radius: 6px;
                cursor: pointer;
                font-weight: 600;
                transition: all 0.3s ease;
                display: flex;
                align-items: center;
                gap: 0.5rem;
                font-size: 0.9rem;
                flex: 1;
                justify-content: center;
            }

            .embedded-widget .btn-primary {
                background: #034638;
                color: white;
            }

            .embedded-widget .btn-primary:hover {
                background: #0a5c4a;
                transform: translateY(-1px);
            }

            .embedded-widget .btn-secondary {
                background: #582C83;
                color: white;
            }

            .embedded-widget .btn-secondary:hover {
                background: #4c1d75;
                transform: translateY(-1px);
            }

            .embedded-widget .btn-reset {
                background: #dc2626;
                color: white;
            }

            .embedded-widget .btn-reset:hover {
                background: #b91c1c;
                transform: translateY(-1px);
            }

            .embedded-widget .dataset-selector {
                display: grid;
                grid-template-columns: repeat(3, 1fr);
                gap: 0.5rem;
                margin: 1rem 0;
            }

            .embedded-widget .dataset-btn {
                background: #f3f4f6;
                border: 2px solid #e5e7eb;
                padding: 0.75rem 0.5rem;
                border-radius: 6px;
                cursor: pointer;
                transition: all 0.3s ease;
                font-size: 0.8rem;
                text-align: center;
                font-weight: 500;
            }

            .embedded-widget .dataset-btn.active {
                background: #034638;
                color: white;
                border-color: #034638;
            }

            .embedded-widget .dataset-btn:hover:not(.active) {
                background: #e5e7eb;
            }

            .embedded-widget .visualization-section {
                margin: 2rem 0;
            }

            .embedded-widget .chart-container {
                background: white;
                border: 1px solid #e5e7eb;
                border-radius: 8px;
                padding: 1rem;
                margin: 1rem 0;
            }

            .embedded-widget .chart-title {
                font-weight: 600;
                color: #374151;
                margin-bottom: 1rem;
                text-align: center;
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 0.5rem;
                font-size: 0.9rem;
            }

            .embedded-widget .clustering-canvas {
                width: 100%;
                height: 350px;
                border: 1px solid #e5e7eb;
                border-radius: 6px;
                background: #f9fafb;
                cursor: crosshair;
            }

            .embedded-widget .metrics-grid {
                display: grid;
                grid-template-columns: repeat(4, 1fr);
                gap: 1rem;
                margin: 1.5rem 0;
            }

            @media (max-width: 768px) {
                .embedded-widget .metrics-grid {
                    grid-template-columns: 1fr 1fr;
                }
            }

            .embedded-widget .metric-card {
                background: #f8fffe;
                border: 1px solid #e5e7eb;
                border-radius: 6px;
                padding: 1rem;
                text-align: center;
                border-left: 4px solid #034638;
            }

            .embedded-widget .metric-title {
                font-size: 0.7rem;
                color: #666;
                margin-bottom: 0.5rem;
                font-weight: 500;
            }

            .embedded-widget .metric-value {
                font-size: 1.3rem;
                font-weight: bold;
                color: #034638;
            }

            .embedded-widget .iteration-info {
                background: #eff6ff;
                border: 2px solid #3b82f6;
                border-radius: 6px;
                padding: 1rem;
                text-align: center;
                margin: 1rem 0;
                font-weight: 600;
                color: #1e40af;
            }

            .embedded-widget .cluster-info {
                background: #fef7ed;
                border: 2px solid #f59e0b;
                border-radius: 8px;
                padding: 1.5rem;
                margin: 2rem 0;
            }

            .embedded-widget .cluster-info h4 {
                font-weight: 600;
                color: #92400e;
                margin-bottom: 1rem;
                display: flex;
                align-items: center;
                gap: 0.5rem;
            }

            .embedded-widget .cluster-legend {
                display: flex;
                gap: 1.5rem;
                flex-wrap: wrap;
                justify-content: center;
                margin-top: 1rem;
            }

            .embedded-widget .cluster-item {
                display: flex;
                align-items: center;
                gap: 0.5rem;
                font-size: 0.9rem;
            }

            .embedded-widget .cluster-color {
                width: 20px;
                height: 20px;
                border-radius: 50%;
                border: 2px solid white;
                box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            }

            @media (max-width: 480px) {
                .embedded-widget .dataset-selector {
                    grid-template-columns: 1fr;
                }

                .embedded-widget .button-group {
                    flex-direction: column;
                }

                .embedded-widget .metrics-grid {
                    grid-template-columns: 1fr;
                }
            }
        </style>

        <div class="dp-wrapper">
            <div class="dp-content-block">
                <h2 class="dp-has-icon">
                    <i class="dp-icon fas fa-project-diagram" aria-hidden="true"></i>
                    K-means Clustering Explorer
                </h2>
                <div class="dp-card intro-card">
                    <p><strong>Interactive Learning:</strong> Explore how K-means clustering groups data points into distinct clusters. Add points by clicking, adjust parameters, and watch the algorithm converge.</p>
                </div>
            </div>

            <div class="controls-section">
                <h3><i class="fas fa-sliders-h" aria-hidden="true"></i> Clustering Configuration</h3>

                <div class="control-group">
                    <label>Dataset Type:</label>
                    <div class="dataset-selector">
                        <button class="dataset-btn active" onclick="selectDataset('random')">Random</button>
                        <button class="dataset-btn" onclick="selectDataset('blobs')">Blobs</button>
                        <button class="dataset-btn" onclick="selectDataset('customer')">Customer</button>
                    </div>
                </div>

                <div class="control-group">
                    <label>Number of Clusters (K):</label>
                    <div class="slider-container">
                        <input type="range" id="kSlider" min="2" max="6" value="3" step="1" onchange="updateK(this.value)">
                        <div class="value-display" id="kValue">3</div>
                    </div>
                </div>

                <div class="control-group">
                    <label>Number of Points:</label>
                    <div class="slider-container">
                        <input type="range" id="pointsSlider" min="30" max="150" value="75" step="15" onchange="updatePoints(this.value)">
                        <div class="value-display" id="pointsValue">75</div>
                    </div>
                </div>

                <div class="button-group">
                    <button class="btn btn-primary" onclick="runClustering()">
                        <i class="fas fa-play" aria-hidden="true"></i> Run Clustering
                    </button>
                    <button class="btn btn-secondary" onclick="stepClustering()">
                        <i class="fas fa-step-forward" aria-hidden="true"></i> Step
                    </button>
                    <button class="btn btn-reset" onclick="resetVisualization()">
                        <i class="fas fa-redo-alt" aria-hidden="true"></i> Reset
                    </button>
                </div>
            </div>

            <div class="iteration-info">
                <i class="fas fa-sync" aria-hidden="true"></i>
                Iteration: <span id="iterationCount">0</span> | Status: <span id="status">Ready</span>
            </div>

            <div class="visualization-section">
                <div class="chart-container">
                    <div class="chart-title">
                        <i class="fas fa-chart-scatter" aria-hidden="true"></i>
                        K-means Clustering Visualization
                    </div>
                    <canvas id="clusteringCanvas" class="clustering-canvas"></canvas>
                </div>
            </div>

            <div class="cluster-info">
                <h4><i class="fas fa-info-circle" aria-hidden="true"></i> Cluster Centers</h4>
                <div class="cluster-legend" id="clusterLegend">
                    <!-- Dynamically populated -->
                </div>
            </div>

            <div class="metrics-grid">
                <div class="metric-card">
                    <div class="metric-title">Inertia (Sum of Squared Distances)</div>
                    <div class="metric-value" id="inertiaValue">-</div>
                </div>
                <div class="metric-card">
                    <div class="metric-title">Convergence</div>
                    <div class="metric-value" id="convergenceValue">-</div>
                </div>
                <div class="metric-card">
                    <div class="metric-title">Points Reassigned</div>
                    <div class="metric-value" id="reassignedValue">-</div>
                </div>
                <div class="metric-card">
                    <div class="metric-title">Silhouette Score</div>
                    <div class="metric-value" id="silhouetteValue">-</div>
                </div>
            </div>
        </div>

        <script>
            // Global variables
            let canvas, ctx;
            let dataPoints = [];
            let centroids = [];
            let assignments = [];
            let k = 3;
            let numPoints = 75;
            let currentDataset = 'random';
            let iteration = 0;
            let isRunning = false;
            let animationId = null;

            // Color palette for clusters
            const clusterColors = [
                '#dc2626', // Red
                '#3b82f6', // Blue
                '#10b981', // Green
                '#f59e0b', // Amber
                '#8b5cf6', // Purple
                '#ec4899'  // Pink
            ];

            function initCanvas() {
                canvas = document.getElementById('clusteringCanvas');
                ctx = canvas.getContext('2d');

                // Set canvas size explicitly
                const rect = canvas.getBoundingClientRect();
                const dpr = window.devicePixelRatio || 1;

                canvas.width = rect.width * dpr;
                canvas.height = rect.height * dpr;

                // Scale context for high-DPI displays
                ctx.scale(dpr, dpr);

                // Ensure canvas displays at correct size
                canvas.style.width = rect.width + 'px';
                canvas.style.height = rect.height + 'px';

                // Add click handler for adding points
                canvas.addEventListener('click', (e) => {
                    if (!isRunning) {
                        const rect = canvas.getBoundingClientRect();
                        const x = (e.clientX - rect.left) / rect.width;
                        const y = (e.clientY - rect.top) / rect.height;
                        dataPoints.push({ x, y });
                        assignments.push(Math.floor(Math.random() * k));
                        drawVisualization();
                    }
                });
            }

            function generateDataset(type) {
                dataPoints = [];
                assignments = [];

                switch(type) {
                    case 'random':
                        for (let i = 0; i < numPoints; i++) {
                            dataPoints.push({
                                x: Math.random(),
                                y: Math.random()
                            });
                            assignments.push(Math.floor(Math.random() * k));
                        }
                        break;

                    case 'blobs':
                        const centers = [];
                        for (let i = 0; i < k; i++) {
                            centers.push({
                                x: 0.2 + Math.random() * 0.6,
                                y: 0.2 + Math.random() * 0.6
                            });
                        }

                        for (let i = 0; i < numPoints; i++) {
                            const center = centers[i % k];
                            const angle = Math.random() * Math.PI * 2;
                            const radius = Math.random() * 0.15;
                            dataPoints.push({
                                x: center.x + Math.cos(angle) * radius,
                                y: center.y + Math.sin(angle) * radius
                            });
                            assignments.push(i % k);
                        }
                        break;

                    case 'customer':
                        // Simulate customer segmentation data
                        // High value - low frequency
                        for (let i = 0; i < numPoints / 3; i++) {
                            dataPoints.push({
                                x: 0.7 + Math.random() * 0.25,
                                y: 0.2 + Math.random() * 0.2
                            });
                            assignments.push(0);
                        }
                        // Medium value - medium frequency
                        for (let i = 0; i < numPoints / 3; i++) {
                            dataPoints.push({
                                x: 0.4 + Math.random() * 0.2,
                                y: 0.4 + Math.random() * 0.2
                            });
                            assignments.push(1);
                        }
                        // Low value - high frequency
                        for (let i = 0; i < numPoints / 3; i++) {
                            dataPoints.push({
                                x: 0.1 + Math.random() * 0.2,
                                y: 0.7 + Math.random() * 0.2
                            });
                            assignments.push(2);
                        }
                        break;
                }

                initializeCentroids();
                drawVisualization();
            }

            function initializeCentroids() {
                centroids = [];
                // K-means++ initialization
                if (dataPoints.length > 0) {
                    // First centroid is random
                    centroids.push({...dataPoints[Math.floor(Math.random() * dataPoints.length)]});

                    // Rest are chosen with probability proportional to squared distance
                    for (let i = 1; i < k; i++) {
                        const distances = dataPoints.map(point => {
                            let minDist = Infinity;
                            centroids.forEach(centroid => {
                                const dist = distance(point, centroid);
                                if (dist < minDist) minDist = dist;
                            });
                            return minDist * minDist;
                        });

                        const sum = distances.reduce((a, b) => a + b, 0);
                        let random = Math.random() * sum;
                        let idx = 0;
                        for (let j = 0; j < distances.length; j++) {
                            random -= distances[j];
                            if (random <= 0) {
                                idx = j;
                                break;
                            }
                        }
                        centroids.push({...dataPoints[idx]});
                    }
                }
            }

            function distance(p1, p2) {
                return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
            }

            function assignToClusters() {
                let changed = 0;
                for (let i = 0; i < dataPoints.length; i++) {
                    let minDist = Infinity;
                    let bestCluster = 0;

                    for (let j = 0; j < centroids.length; j++) {
                        const dist = distance(dataPoints[i], centroids[j]);
                        if (dist < minDist) {
                            minDist = dist;
                            bestCluster = j;
                        }
                    }

                    if (assignments[i] !== bestCluster) {
                        changed++;
                        assignments[i] = bestCluster;
                    }
                }
                return changed;
            }

            function updateCentroids() {
                const newCentroids = [];

                for (let i = 0; i < k; i++) {
                    const clusterPoints = dataPoints.filter((_, idx) => assignments[idx] === i);

                    if (clusterPoints.length > 0) {
                        const sumX = clusterPoints.reduce((sum, p) => sum + p.x, 0);
                        const sumY = clusterPoints.reduce((sum, p) => sum + p.y, 0);
                        newCentroids.push({
                            x: sumX / clusterPoints.length,
                            y: sumY / clusterPoints.length
                        });
                    } else {
                        // Keep old centroid if no points assigned
                        newCentroids.push(centroids[i] || { x: 0.5, y: 0.5 });
                    }
                }

                centroids = newCentroids;
            }

            function calculateInertia() {
                let inertia = 0;
                for (let i = 0; i < dataPoints.length; i++) {
                    const dist = distance(dataPoints[i], centroids[assignments[i]]);
                    inertia += dist * dist;
                }
                return inertia;
            }

            function calculateSilhouette() {
                // Simplified silhouette score calculation
                if (k === 1 || dataPoints.length < k) return 0;

                let totalScore = 0;
                for (let i = 0; i < dataPoints.length; i++) {
                    const point = dataPoints[i];
                    const cluster = assignments[i];

                    // Average distance to points in same cluster
                    const sameCluster = dataPoints.filter((_, idx) => assignments[idx] === cluster && idx !== i);
                    const a = sameCluster.length > 0 ?
                        sameCluster.reduce((sum, p) => sum + distance(point, p), 0) / sameCluster.length : 0;

                    // Minimum average distance to points in other clusters
                    let b = Infinity;
                    for (let c = 0; c < k; c++) {
                        if (c !== cluster) {
                            const otherCluster = dataPoints.filter((_, idx) => assignments[idx] === c);
                            if (otherCluster.length > 0) {
                                const avgDist = otherCluster.reduce((sum, p) => sum + distance(point, p), 0) / otherCluster.length;
                                if (avgDist < b) b = avgDist;
                            }
                        }
                    }

                    if (b === Infinity) b = 0;
                    const s = b === 0 && a === 0 ? 0 : (b - a) / Math.max(a, b);
                    totalScore += s;
                }

                return totalScore / dataPoints.length;
            }

            function drawVisualization() {
                const rect = canvas.getBoundingClientRect();
                const width = rect.width;
                const height = rect.height;

                ctx.clearRect(0, 0, width, height);

                // Draw grid
                ctx.strokeStyle = '#e5e7eb';
                ctx.lineWidth = 0.5;
                for (let i = 0; i <= 10; i++) {
                    ctx.beginPath();
                    ctx.moveTo(0, i * height / 10);
                    ctx.lineTo(width, i * height / 10);
                    ctx.moveTo(i * width / 10, 0);
                    ctx.lineTo(i * width / 10, height);
                    ctx.stroke();
                }

                // Draw data points
                dataPoints.forEach((point, idx) => {
                    const px = point.x * width;
                    const py = point.y * height;
                    const cluster = assignments[idx];

                    ctx.beginPath();
                    ctx.arc(px, py, 4, 0, Math.PI * 2);
                    ctx.fillStyle = clusterColors[cluster % clusterColors.length];
                    ctx.fill();
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                });

                // Draw centroids
                centroids.forEach((centroid, idx) => {
                    const cx = centroid.x * width;
                    const cy = centroid.y * height;

                    // Draw cross for centroid
                    ctx.strokeStyle = clusterColors[idx % clusterColors.length];
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(cx - 8, cy);
                    ctx.lineTo(cx + 8, cy);
                    ctx.moveTo(cx, cy - 8);
                    ctx.lineTo(cx, cy + 8);
                    ctx.stroke();

                    // Draw circle around centroid
                    ctx.beginPath();
                    ctx.arc(cx, cy, 12, 0, Math.PI * 2);
                    ctx.strokeStyle = clusterColors[idx % clusterColors.length];
                    ctx.lineWidth = 2;
                    ctx.stroke();
                });

                // Update metrics
                updateMetrics();
            }

            function updateMetrics() {
                const inertia = calculateInertia();
                const silhouette = calculateSilhouette();

                document.getElementById('inertiaValue').textContent = inertia.toFixed(3);
                document.getElementById('silhouetteValue').textContent = silhouette.toFixed(3);
                document.getElementById('iterationCount').textContent = iteration;

                // Update cluster legend
                const legend = document.getElementById('clusterLegend');
                legend.innerHTML = '';
                for (let i = 0; i < k; i++) {
                    const count = assignments.filter(a => a === i).length;
                    const item = document.createElement('div');
                    item.className = 'cluster-item';
                    item.innerHTML = `
                        <div class="cluster-color" style="background: ${clusterColors[i]}"></div>
                        <span>Cluster ${i + 1}: ${count} points</span>
                    `;
                    legend.appendChild(item);
                }
            }

            function stepClustering() {
                if (dataPoints.length === 0) {
                    generateDataset(currentDataset);
                }

                const changed = assignToClusters();
                updateCentroids();
                iteration++;

                drawVisualization();

                document.getElementById('reassignedValue').textContent = changed;
                document.getElementById('convergenceValue').textContent = changed === 0 ? 'Yes' : 'No';
                document.getElementById('status').textContent = changed === 0 ? 'Converged' : 'Running';

                if (changed === 0) {
                    isRunning = false;
                    document.getElementById('status').textContent = 'Converged';
                }
            }

            function runClustering() {
                if (isRunning) {
                    isRunning = false;
                    if (animationId) {
                        cancelAnimationFrame(animationId);
                    }
                    document.getElementById('status').textContent = 'Stopped';
                    return;
                }

                if (dataPoints.length === 0) {
                    generateDataset(currentDataset);
                }

                isRunning = true;
                document.getElementById('status').textContent = 'Running';

                function animate() {
                    const changed = assignToClusters();
                    updateCentroids();
                    iteration++;

                    drawVisualization();

                    document.getElementById('reassignedValue').textContent = changed;
                    document.getElementById('convergenceValue').textContent = changed === 0 ? 'Yes' : 'No';

                    if (changed === 0 || iteration > 50) {
                        isRunning = false;
                        document.getElementById('status').textContent = 'Converged';
                    } else if (isRunning) {
                        animationId = setTimeout(() => requestAnimationFrame(animate), 500);
                    }
                }

                animate();
            }

            function selectDataset(type) {
                currentDataset = type;
                document.querySelectorAll('.dataset-btn').forEach(btn => btn.classList.remove('active'));
                event.target.classList.add('active');
                generateDataset(type);
                iteration = 0;
                document.getElementById('status').textContent = 'Ready';
            }

            function updateK(value) {
                k = parseInt(value);
                document.getElementById('kValue').textContent = value;
                initializeCentroids();
                // Reassign all points randomly
                assignments = dataPoints.map(() => Math.floor(Math.random() * k));
                drawVisualization();
                iteration = 0;
                document.getElementById('status').textContent = 'Ready';
            }

            function updatePoints(value) {
                numPoints = parseInt(value);
                document.getElementById('pointsValue').textContent = value;
                generateDataset(currentDataset);
                iteration = 0;
                document.getElementById('status').textContent = 'Ready';
            }

            function resetVisualization() {
                isRunning = false;
                if (animationId) {
                    cancelAnimationFrame(animationId);
                }
                iteration = 0;
                generateDataset(currentDataset);
                document.getElementById('status').textContent = 'Ready';
                document.getElementById('reassignedValue').textContent = '-';
                document.getElementById('convergenceValue').textContent = '-';
            }

            // Initialize when DOM is ready
            document.addEventListener('DOMContentLoaded', () => {
                setTimeout(() => {
                    try {
                        initCanvas();
                        generateDataset('random');
                        document.getElementById('status').textContent = 'Ready - Click Run Clustering';
                    } catch (error) {
                        console.error('Widget initialization error:', error);
                        document.getElementById('status').textContent = 'Error - Try clicking Reset';
                    }
                }, 100);
            });

            // Handle resize
            window.addEventListener('resize', () => {
                setTimeout(() => {
                    initCanvas();
                    if (dataPoints.length > 0) {
                        drawVisualization();
                    }
                }, 100);
            });
        </script>
    </div>
  </div>

  <div class="dp-callout dp-callout-placeholder card dp-callout-position-default w-100 dp-callout-type-default dp-callout-color-dp-primary">
    <div class="card-body">
      <h3 class="card-title">Pro Tip</h3>
      <p class="card-text">Run K-means multiple times with different initializations and choose the result with lowest within-cluster sum of squares for more stable results.</p>
    </div>
  </div>

  <div class="dp-callout dp-callout-placeholder card dp-callout-position-default w-100 dp-callout-color-dp-primary dp-callout-type-warning">
    <div class="dp-callout-side-emphasis"><i class="dp-icon fas fa-exclamation-triangle dp-default-icon" aria-hidden="true"></i></div>
    <div class="card-body">
      <h4 class="card-title">Remember</h4>
      <p class="card-text">Always scale your features before applying K-means. Age (20-80) and income ($20K-$200K) need normalization to prevent income from dominating the clustering.</p>
    </div>
  </div>

  <hr aria-hidden="true" />
  <p>Select <strong>Next▸</strong> to continue.</p>
</div>
</main>

<script>
(function () {
  function toggleHead(h){
    const content = document.getElementById(h.getAttribute('aria-controls'));
    const expanded = h.getAttribute('aria-expanded') === 'true';
    h.setAttribute('aria-expanded', String(!expanded));
    if (content) content.hidden = expanded;
  }
  document.addEventListener('click', function (e) {
    const h = e.target.closest('.dp-panel-heading[role="button"]');
    if (h) toggleHead(h);
  });
  document.addEventListener('keydown', function (e) {
    if ((e.key === 'Enter' || e.key === ' ') && e.target.matches('.dp-panel-heading[role="button"]')) {
      e.preventDefault(); toggleHead(e.target);
    }
  });
})();
</script>