<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Threshold Cost Explorer - AMBA Template</title>
  <!-- Canvas iframe sizing hint -->
  <meta name="canvas-height" content="680">
  <meta name="description" content="Cost-sensitive threshold optimization with interactive Plotly charts">
  <link rel="stylesheet" href="../../shared/ivey-widget-base.css">
  <script src="https://cdn.plot.ly/plotly-2.28.0.min.js"></script>
  <style>
    /* Widget-specific styling */
    .controls-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 15px;
      margin-bottom: 15px;
    }

    .cost-matrix {
      display: grid;
      grid-template-columns: 80px 1fr 1fr;
      gap: 1px;
      background: #ddd;
      border-radius: 8px;
      overflow: hidden;
      margin: 10px 0;
      font-size: 0.85em;
    }

    .matrix-cell {
      background: white;
      padding: 8px;
      text-align: center;
    }

    .matrix-header {
      background: var(--ivey-green);
      color: white;
      font-weight: bold;
      font-size: 0.8em;
    }

    .matrix-label {
      background: var(--bg-secondary);
      font-weight: bold;
      font-size: 0.8em;
    }

    .tp { background: #d4edda !important; }
    .fn { background: #f8d7da !important; }
    .fp { background: #fff3cd !important; }
    .tn { background: #d1ecf1 !important; }

    .cost-value {
      font-size: 1.2em;
      font-weight: bold;
    }

    .cost-positive {
      color: var(--success-color);
    }

    .cost-negative {
      color: var(--danger-color);
    }

    .optimal-indicator {
      background: #d4edda;
      border: 2px solid var(--success-color);
      border-radius: 8px;
      padding: 15px;
      margin: 15px 0;
      text-align: center;
    }

    .optimal-text {
      color: var(--success-color);
      font-weight: bold;
      font-size: 1.1em;
    }
  </style>
</head>
<body>
  <!-- Pop-out button for full window view -->
  <button class="widget-popout-btn" id="popoutBtn" title="Open in full window">
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14" />
    </svg>
    <span>Pop Out</span>
  </button>

<div class="dp-wrapper">
  <div class="widget-header">
    <h1 class="widget-title">Threshold Cost Explorer</h1>
  </div>

  <div class="controls-grid">
    <div class="control-panel">
      <div class="panel-title">Decision Threshold</div>
      <div class="control-group">
        <div class="slider-container">
          <input type="range" class="slider" id="threshold-slider"
                 min="0" max="1" step="0.01" value="0.5">
          <div class="slider-value" id="threshold-value">0.50</div>
        </div>
      </div>
    </div>

    <div class="control-panel">
      <div class="panel-title">Cost Structure ($)</div>
      <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; font-size: 0.85em;">
        <div>
          <label class="control-label">False Positive:</label>
          <input type="number" id="fp-cost" value="5" min="0" step="1" style="width: 60px;">
        </div>
        <div>
          <label class="control-label">False Negative:</label>
          <input type="number" id="fn-cost" value="500" min="0" step="10" style="width: 60px;">
        </div>
      </div>
    </div>
  </div>

  <div class="metrics-grid">
    <div class="metric-card">
      <div class="metric-label">True Positives</div>
      <div class="metric-value" id="tp-count">40</div>
    </div>
    <div class="metric-card">
      <div class="metric-label">False Positives</div>
      <div class="metric-value" id="fp-count">100</div>
    </div>
    <div class="metric-card">
      <div class="metric-label">False Negatives</div>
      <div class="metric-value" id="fn-count">10</div>
    </div>
    <div class="metric-card">
      <div class="metric-label">Expected Net Value</div>
      <div class="cost-value" id="net-value">$12,500</div>
    </div>
  </div>


  <div id="optimal-threshold" class="optimal-indicator">
    <div class="optimal-text">
      Optimal Threshold: <span id="optimal-value-1">0.62</span>
      (Net Value: $<span id="optimal-net">15,240</span>)
    </div>
  </div>

  <div class="plot-container">
    <div id="cost-threshold-plot" style="height: 300px;"></div>
  </div>

  <div id="insights" class="insight-box">
    <strong>Optimal Threshold: <span id="optimal-value-2">0.62</span></strong><br>
    <span id="insight-text">Adjust threshold and costs to find the optimal decision point.</span>
  </div>
</div>

<script>
// Simulated model data
const n_samples = 1000;
const positiveRate = 0.05; // 5% positive class
const scores = [];
const trueLabels = [];

// Generate synthetic data
for (let i = 0; i < n_samples; i++) {
  const isPositive = Math.random() < positiveRate;
  trueLabels.push(isPositive ? 1 : 0);

  if (isPositive) {
    // Positive samples: higher scores on average
    scores.push(Math.random() * 0.4 + 0.5 + (Math.random() - 0.5) * 0.2);
  } else {
    // Negative samples: lower scores on average
    scores.push(Math.random() * 0.6 + (Math.random() - 0.5) * 0.2);
  }
}

function calculateCostMetrics(threshold, fpCost, fnCost, tpBenefit) {
  let tp = 0, fp = 0, tn = 0, fn = 0;

  for (let i = 0; i < n_samples; i++) {
    const predicted = scores[i] >= threshold ? 1 : 0;
    const actual = trueLabels[i];

    if (predicted === 1 && actual === 1) tp++;
    else if (predicted === 1 && actual === 0) fp++;
    else if (predicted === 0 && actual === 0) tn++;
    else if (predicted === 0 && actual === 1) fn++;
  }

  const precision = tp + fp > 0 ? tp / (tp + fp) : 0;
  const recall = tp + fn > 0 ? tp / (tp + fn) : 0;

  // Calculate costs and benefits
  const tpValue = tp * tpBenefit;
  const fpValue = fp * fpCost;
  const fnValue = fn * fnCost;
  const tnValue = 0; // Neutral

  const netValue = tpValue - fpValue - fnValue + tnValue;
  const perTransaction = netValue / n_samples;

  return {
    tp, fp, tn, fn,
    precision, recall,
    tpValue, fpValue, fnValue, tnValue,
    netValue, perTransaction
  };
}

function findOptimalThreshold(fpCost, fnCost, tpBenefit) {
  let bestThreshold = 0.5;
  let bestNetValue = -Infinity;

  for (let t = 0.01; t <= 0.99; t += 0.01) {
    const metrics = calculateCostMetrics(t, fpCost, fnCost, tpBenefit);
    if (metrics.netValue > bestNetValue) {
      bestNetValue = metrics.netValue;
      bestThreshold = t;
    }
  }

  return { threshold: bestThreshold, netValue: bestNetValue };
}

function updateMetrics() {
  const threshold = parseFloat(document.getElementById('threshold-slider').value);
  const fpCost = parseFloat(document.getElementById('fp-cost').value);
  const fnCost = parseFloat(document.getElementById('fn-cost').value);
  const tpBenefit = 100; // Default benefit value since tp-benefit input doesn't exist

  const metrics = calculateCostMetrics(threshold, fpCost, fnCost, tpBenefit);
  const optimal = findOptimalThreshold(fpCost, fnCost, tpBenefit);

  // Update threshold display
  document.getElementById('threshold-value').textContent = threshold.toFixed(2);

  // Update confusion matrix
  document.getElementById('tp-count').textContent = metrics.tp;
  document.getElementById('fp-count').textContent = metrics.fp;
  document.getElementById('fn-count').textContent = metrics.fn;


  const netValueEl = document.getElementById('net-value');
  netValueEl.textContent = '$' + metrics.netValue.toLocaleString();
  netValueEl.className = metrics.netValue >= 0 ? 'cost-value cost-positive' : 'cost-value cost-negative';

  // Update optimal threshold (both instances)
  document.getElementById('optimal-value-1').textContent = optimal.threshold.toFixed(2);
  document.getElementById('optimal-value-2').textContent = optimal.threshold.toFixed(2);
  document.getElementById('optimal-net').textContent = optimal.netValue.toLocaleString();

  // Update plot
  updatePlot(threshold, fpCost, fnCost, tpBenefit, optimal.threshold);

  // Update insights
  updateInsights(threshold, metrics, optimal, fpCost, fnCost);
}

function updatePlot(currentThreshold, fpCost, fnCost, tpBenefit, optimalThreshold) {
  const thresholds = [];
  const netValues = [];

  for (let t = 0.01; t <= 0.99; t += 0.01) {
    thresholds.push(t);
    const metrics = calculateCostMetrics(t, fpCost, fnCost, tpBenefit);
    netValues.push(metrics.netValue);
  }

  const trace1 = {
    x: thresholds,
    y: netValues,
    type: 'scatter',
    mode: 'lines',
    name: 'Expected Net Value',
    line: { color: '#034638', width: 3 }
  };

  const trace2 = {
    x: [currentThreshold],
    y: [calculateCostMetrics(currentThreshold, fpCost, fnCost, tpBenefit).netValue],
    type: 'scatter',
    mode: 'markers',
    name: 'Current Threshold',
    marker: {
      color: '#582C83',
      size: 12,
      symbol: 'diamond'
    }
  };

  const trace3 = {
    x: [optimalThreshold],
    y: [calculateCostMetrics(optimalThreshold, fpCost, fnCost, tpBenefit).netValue],
    type: 'scatter',
    mode: 'markers',
    name: 'Optimal Threshold',
    marker: {
      color: '#198754',
      size: 12,
      symbol: 'star'
    }
  };

  const layout = {
    title: 'Expected Net Value vs Decision Threshold',
    xaxis: {
      title: 'Decision Threshold',
      range: [0, 1]
    },
    yaxis: {
      title: 'Expected Net Value ($)'
    },
    showlegend: true,
    margin: { t: 50, b: 50, l: 80, r: 20 }
  };

  Plotly.newPlot('cost-threshold-plot', [trace1, trace2, trace3], layout, {responsive: true});
}

function updateInsights(threshold, metrics, optimal, fpCost, fnCost) {
  let insight = `At threshold ${threshold.toFixed(2)}: `;

  const isOptimal = Math.abs(threshold - optimal.threshold) < 0.05;

  if (isOptimal) {
    insight += "This threshold is near optimal for the given cost structure. ";
  } else if (threshold < optimal.threshold) {
    insight += "This threshold is too low - you're accepting too many false positives. ";
  } else {
    insight += "This threshold is too high - you're missing too many true positives. ";
  }

  const costRatio = fnCost / fpCost;
  insight += `With FN cost ${costRatio.toFixed(0)}x higher than FP cost, `;

  if (costRatio > 50) {
    insight += "false negatives are very expensive - use a lower threshold to catch more positives.";
  } else if (costRatio < 5) {
    insight += "false positives are relatively expensive - use a higher threshold to reduce false alarms.";
  } else {
    insight += "there's a moderate trade-off between missing positives and false alarms.";
  }

  document.getElementById('insight-text').textContent = insight;
}

// Event listeners
document.getElementById('threshold-slider').addEventListener('input', updateMetrics);
document.getElementById('fp-cost').addEventListener('input', updateMetrics);
document.getElementById('fn-cost').addEventListener('input', updateMetrics);

// Initialize
updateMetrics();

// Pop-out functionality
document.getElementById('popoutBtn').addEventListener('click', function() {
  const currentUrl = window.location.href;
  const popoutUrl = currentUrl + (currentUrl.includes('?') ? '&' : '?') + 'standalone=true';
  const popoutWindow = window.open(popoutUrl, 'WidgetPopout', 'width=1200,height=900,resizable=yes,scrollbars=yes,status=yes');
  if (popoutWindow) popoutWindow.focus();
});
if (window.location.search.includes('standalone=true')) {
  document.body.classList.add('standalone-mode');
}
</script>

</body>
</html>