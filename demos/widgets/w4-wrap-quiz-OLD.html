<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Week 4 Wrap-Up Quiz - Generative AI</title>
  <!-- Canvas iframe sizing hint -->
  <meta name="canvas-height" content="900">
  <meta name="description" content="Test your knowledge of Generative AI, LLMs, transformers, prompt engineering, fine-tuning, RAG, and AI agents">
  <link rel="stylesheet" href="ivey-widget-base.css">
  <style>
    /* Widget-specific styling */
    .quiz-progress {
      background: var(--bg-secondary);
      border: 1px solid #ddd;
      border-radius: 8px;
      padding: 10px;
      margin-bottom: 20px;
      text-align: center;
    }

    .progress-bar {
      background: #e9ecef;
      border-radius: 4px;
      height: 8px;
      margin: 10px 0;
      overflow: hidden;
    }

    .progress-fill {
      background: var(--ivey-green);
      height: 100%;
      transition: width 0.3s ease;
      width: 0%;
    }

    .question-number {
      color: var(--ivey-green);
      font-weight: bold;
      font-size: 0.9em;
      margin-bottom: 10px;
    }

    .answer-options {
      list-style: none;
      padding: 0;
    }

    .answer-option {
      background: var(--bg-secondary);
      border: 2px solid #ddd;
      border-radius: 8px;
      padding: 12px;
      margin: 8px 0;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .answer-option:hover {
      background: #e9ecef;
      border-color: var(--ivey-green);
    }

    .answer-option.selected {
      background: var(--ivey-green);
      color: white;
      border-color: var(--ivey-green);
    }

    .answer-option.correct {
      background: #d4edda;
      border-color: var(--success-color);
      color: #155724;
    }

    .answer-option.incorrect {
      background: #f8d7da;
      border-color: var(--danger-color);
      color: #721c24;
    }

    .score-display {
      font-size: 2em;
      font-weight: bold;
      color: var(--ivey-green);
      margin: 15px 0;
    }

    .score-excellent {
      color: var(--success-color);
    }

    .score-good {
      color: #fd7e14;
    }

    .score-needs-improvement {
      color: var(--danger-color);
    }

    .topic-review {
      margin: 10px 0;
      padding: 8px;
      border-radius: 4px;
    }

    .topic-mastered {
      background: #d4edda;
      color: #155724;
    }

    .topic-needs-review {
      background: #fff3cd;
      color: #856404;
    }
  </style>
</head>
<body>

<div class="dp-wrapper">
  <div class="widget-header">
    <h1 class="widget-title">Week 4 Knowledge Check Quiz</h1>
  </div>

  <div class="quiz-progress">
    <div>Question <span id="current-question">1</span> of <span id="total-questions">6</span></div>
    <div class="progress-bar">
      <div class="progress-fill" id="progress-fill"></div>
    </div>
  </div>

  <!-- Question 1 -->
  <div class="question-card active" data-question="1">
    <div class="question-number">Question 1</div>
    <div class="question-text">When should you prefer PR (Precision-Recall) curves over ROC curves for model evaluation?</div>
    <ul class="answer-options">
      <li class="answer-option" data-answer="a">When you have balanced classes and want to see overall model performance</li>
      <li class="answer-option" data-answer="b">When the positive class is rare and you care about precision/recall trade-offs directly</li>
      <li class="answer-option" data-answer="c">When you want to maximize accuracy regardless of class distribution</li>
      <li class="answer-option" data-answer="d">When computational efficiency is the primary concern</li>
    </ul>
    <div class="explanation">
      <div class="explanation-title">✓ Correct Answer: B</div>
      <p>PR curves are preferred when the positive class is rare (imbalanced data) because they focus on the performance in the minority class. ROC curves can be overly optimistic with imbalanced data since they include true negative rate, which is easy to achieve when most samples are negative.</p>
    </div>
  </div>

  <!-- Question 2 -->
  <div class="question-card" data-question="2">
    <div class="question-number">Question 2</div>
    <div class="question-text">Why is it important to keep preprocessing inside the cross-validation pipeline?</div>
    <ul class="answer-options">
      <li class="answer-option" data-answer="a">To make the code run faster and more efficiently</li>
      <li class="answer-option" data-answer="b">To avoid data leakage by ensuring statistics are learned only on training folds</li>
      <li class="answer-option" data-answer="c">To reduce memory usage during model training</li>
      <li class="answer-option" data-answer="d">To ensure consistent formatting across all datasets</li>
    </ul>
    <div class="explanation">
      <div class="explanation-title">✓ Correct Answer: B</div>
      <p>Preprocessing must be inside the CV loop to prevent data leakage. If you fit preprocessing (like scalers) on the entire dataset before splitting, information from validation folds "leaks" into training, leading to overly optimistic performance estimates.</p>
    </div>
  </div>

  <!-- Question 3 -->
  <div class="question-card" data-question="3">
    <div class="question-text">What does early stopping help prevent, and how does it work?</div>
    <ul class="answer-options">
      <li class="answer-option" data-answer="a">Underfitting by stopping training before the model learns enough patterns</li>
      <li class="answer-option" data-answer="b">Overfitting by halting training when validation performance stops improving</li>
      <li class="answer-option" data-answer="c">Data leakage by preventing access to test data during training</li>
      <li class="answer-option" data-answer="d">Computational errors by stopping before memory overflow occurs</li>
    </ul>
    <div class="explanation">
      <div class="explanation-title">✓ Correct Answer: B</div>
      <p>Early stopping prevents overfitting by monitoring validation performance and stopping training when it plateaus or starts declining. This saves computational time and prevents the model from memorizing training data.</p>
    </div>
  </div>

  <!-- Question 4 -->
  <div class="question-card" data-question="4">
    <div class="question-text">How do you translate a classification threshold choice into business terms?</div>
    <ul class="answer-options">
      <li class="answer-option" data-answer="a">Use accuracy as the primary metric and choose the threshold that maximizes it</li>
      <li class="answer-option" data-answer="b">Always use 0.5 as the threshold since it's the mathematical default</li>
      <li class="answer-option" data-answer="c">Use a cost matrix and expected value calculation to pick the cutoff that maximizes net benefit</li>
      <li class="answer-option" data-answer="d">Choose the threshold that minimizes the total number of errors</li>
    </ul>
    <div class="explanation">
      <div class="explanation-title">✓ Correct Answer: C</div>
      <p>Business decisions require considering the costs of false positives vs false negatives. A cost matrix captures these business costs, and expected value calculations help find the threshold that maximizes net business benefit, not just accuracy.</p>
    </div>
  </div>

  <!-- Question 5 -->
  <div class="question-card" data-question="5">
    <div class="question-text">In a fraud detection system, which metric is typically most important and why?</div>
    <ul class="answer-options">
      <li class="answer-option" data-answer="a">Accuracy, because it gives the overall correct prediction rate</li>
      <li class="answer-option" data-answer="b">Precision, because false alarms are expensive to investigate</li>
      <li class="answer-option" data-answer="c">Recall, because missing fraud cases is very costly</li>
      <li class="answer-option" data-answer="d">F1-score, because it balances precision and recall equally</li>
    </ul>
    <div class="explanation">
      <div class="explanation-title">✓ Correct Answer: C</div>
      <p>In fraud detection, recall is typically most critical because the cost of missing a fraud case (false negative) is usually much higher than the cost of investigating a false alarm (false positive). However, the specific answer depends on the business context and cost structure.</p>
    </div>
  </div>

  <!-- Question 6 -->
  <div class="question-card" data-question="6">
    <div class="question-text">What is lift in the context of model evaluation, and why is it useful for business applications?</div>
    <ul class="answer-options">
      <li class="answer-option" data-answer="a">A measure of how much the model improves over random selection for targeting</li>
      <li class="answer-option" data-answer="b">The difference between training and validation accuracy</li>
      <li class="answer-option" data-answer="c">The computational speed improvement of the model over baseline methods</li>
      <li class="answer-option" data-answer="d">The percentage increase in revenue after deploying the model</li>
    </ul>
    <div class="explanation">
      <div class="explanation-title">✓ Correct Answer: A</div>
      <p>Lift measures how much better your model performs compared to random selection when targeting a specific population segment. For example, 3x lift in the top decile means you're 3 times more likely to find positives than random selection. This is valuable for marketing campaigns, risk management, and resource allocation.</p>
    </div>
  </div>

  <div class="nav-buttons">
    <button class="btn" id="prev-btn" onclick="previousQuestion()" disabled>Previous</button>
    <button class="btn btn-secondary" id="next-btn" onclick="nextQuestion()" disabled>Next</button>
    <button class="btn" id="submit-btn" onclick="submitQuiz()" style="display: none;">Submit Quiz</button>
  </div>

  <div class="quiz-results" id="quiz-results">
    <div class="results-title">Quiz Complete!</div>
    <div class="score-display" id="final-score">-</div>
    <div class="results-summary" id="results-summary">
      <!-- Results will be populated by JavaScript -->
    </div>
    <button class="btn" onclick="restartQuiz()">Retake Quiz</button>
  </div>
</div>

<script>
const questions = [
  {
    id: 1,
    correct: 'b',
    topic: 'Model Evaluation Metrics'
  },
  {
    id: 2,
    correct: 'b',
    topic: 'Cross-Validation'
  },
  {
    id: 3,
    correct: 'b',
    topic: 'Overfitting Prevention'
  },
  {
    id: 4,
    correct: 'c',
    topic: 'Business Metrics'
  },
  {
    id: 5,
    correct: 'c',
    topic: 'Business Context'
  },
  {
    id: 6,
    correct: 'a',
    topic: 'Lift and Targeting'
  }
];

let currentQuestionIndex = 0;
let selectedAnswers = {};
let showingResults = false;

function updateProgress() {
  const progress = ((currentQuestionIndex + 1) / questions.length) * 100;
  document.getElementById('progress-fill').style.width = progress + '%';
  document.getElementById('current-question').textContent = currentQuestionIndex + 1;
  document.getElementById('total-questions').textContent = questions.length;
}

function showQuestion(index) {
  // Hide all questions
  document.querySelectorAll('.question-card').forEach(card => {
    card.classList.remove('active');
  });

  // Show current question
  const questionCard = document.querySelector(`[data-question="${index + 1}"]`);
  questionCard.classList.add('active');

  // Update navigation buttons
  document.getElementById('prev-btn').disabled = index === 0;
  document.getElementById('next-btn').style.display = index === questions.length - 1 ? 'none' : 'inline-block';
  document.getElementById('submit-btn').style.display = index === questions.length - 1 ? 'inline-block' : 'none';

  // Restore selected answer if exists
  const selectedAnswer = selectedAnswers[index + 1];
  if (selectedAnswer) {
    const option = questionCard.querySelector(`[data-answer="${selectedAnswer}"]`);
    if (option) {
      option.classList.add('selected');
      document.getElementById('next-btn').disabled = false;
      document.getElementById('submit-btn').disabled = false;
    }
  } else {
    document.getElementById('next-btn').disabled = true;
    document.getElementById('submit-btn').disabled = true;
  }

  updateProgress();
}

function selectAnswer(questionId, answer) {
  selectedAnswers[questionId] = answer;

  // Update UI
  const questionCard = document.querySelector(`[data-question="${questionId}"]`);
  questionCard.querySelectorAll('.answer-option').forEach(option => {
    option.classList.remove('selected');
  });

  const selectedOption = questionCard.querySelector(`[data-answer="${answer}"]`);
  selectedOption.classList.add('selected');

  // Enable next/submit button
  document.getElementById('next-btn').disabled = false;
  document.getElementById('submit-btn').disabled = false;
}

function nextQuestion() {
  if (currentQuestionIndex < questions.length - 1) {
    currentQuestionIndex++;
    showQuestion(currentQuestionIndex);
  }
}

function previousQuestion() {
  if (currentQuestionIndex > 0) {
    currentQuestionIndex--;
    showQuestion(currentQuestionIndex);
  }
}

function submitQuiz() {
  showingResults = true;

  // Calculate score
  let correctCount = 0;
  const topicScores = {};

  questions.forEach(question => {
    const userAnswer = selectedAnswers[question.id];
    const isCorrect = userAnswer === question.correct;

    if (isCorrect) correctCount++;

    // Track topic performance
    if (!topicScores[question.topic]) {
      topicScores[question.topic] = { correct: 0, total: 0 };
    }
    topicScores[question.topic].total++;
    if (isCorrect) topicScores[question.topic].correct++;

    // Show correct/incorrect styling
    const questionCard = document.querySelector(`[data-question="${question.id}"]`);
    questionCard.querySelectorAll('.answer-option').forEach(option => {
      const answer = option.getAttribute('data-answer');

      if (answer === question.correct) {
        option.classList.add('correct');
      } else if (answer === userAnswer && answer !== question.correct) {
        option.classList.add('incorrect');
      }
    });

    // Show explanation
    questionCard.querySelector('.explanation').classList.add('show');
  });

  // Display results
  const percentage = Math.round((correctCount / questions.length) * 100);
  const scoreDisplay = document.getElementById('final-score');
  scoreDisplay.textContent = `${correctCount}/${questions.length} (${percentage}%)`;

  // Color-code score
  if (percentage >= 85) {
    scoreDisplay.className = 'score-display score-excellent';
  } else if (percentage >= 70) {
    scoreDisplay.className = 'score-display score-good';
  } else {
    scoreDisplay.className = 'score-display score-needs-improvement';
  }

  // Generate topic summary
  let summaryHTML = '<h4>Topic Performance:</h4>';
  Object.entries(topicScores).forEach(([topic, scores]) => {
    const topicPercentage = Math.round((scores.correct / scores.total) * 100);
    const topicClass = topicPercentage >= 75 ? 'topic-mastered' : 'topic-needs-review';
    summaryHTML += `
      <div class="topic-review ${topicClass}">
        <strong>${topic}:</strong> ${scores.correct}/${scores.total} (${topicPercentage}%)
        ${topicPercentage < 75 ? ' - Recommend review' : ' - Well understood'}
      </div>
    `;
  });

  // Add study recommendations based on performance
  if (percentage < 70) {
    summaryHTML += '<br><strong>Recommendations:</strong><br>';
    summaryHTML += '• Review Week 4 materials on model evaluation and business metrics<br>';
    summaryHTML += '• Practice with threshold optimization exercises<br>';
    summaryHTML += '• Focus on understanding the business context of ML metrics';
  } else if (percentage < 85) {
    summaryHTML += '<br><strong>Good work!</strong> Consider reviewing topics marked for improvement.';
  } else {
    summaryHTML += '<br><strong>Excellent!</strong> You have a solid understanding of Week 4 concepts.';
  }

  document.getElementById('results-summary').innerHTML = summaryHTML;

  // Hide quiz, show results
  document.querySelector('.quiz-progress').style.display = 'none';
  document.querySelectorAll('.question-card').forEach(card => {
    card.style.display = 'none';
  });
  document.querySelector('.nav-buttons').style.display = 'none';
  document.getElementById('quiz-results').classList.add('show');
}

function restartQuiz() {
  // Reset state
  currentQuestionIndex = 0;
  selectedAnswers = {};
  showingResults = false;

  // Reset UI
  document.querySelector('.quiz-progress').style.display = 'block';
  document.querySelector('.nav-buttons').style.display = 'flex';
  document.getElementById('quiz-results').classList.remove('show');

  // Reset question styling
  document.querySelectorAll('.question-card').forEach(card => {
    card.style.display = 'block';
    card.querySelectorAll('.answer-option').forEach(option => {
      option.classList.remove('selected', 'correct', 'incorrect');
    });
    card.querySelector('.explanation').classList.remove('show');
  });

  // Show first question
  showQuestion(0);
}

// Event delegation for answer selection
document.addEventListener('click', function(e) {
  if (e.target.classList.contains('answer-option') && !showingResults) {
    const questionCard = e.target.closest('.question-card');
    const questionId = parseInt(questionCard.getAttribute('data-question'));
    const answer = e.target.getAttribute('data-answer');
    selectAnswer(questionId, answer);
  }
});

// Initialize
showQuestion(0);
</script>

</body>
</html>