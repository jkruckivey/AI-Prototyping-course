<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Perceptron Playground</title>
    <link rel="stylesheet" href="ivey-widget-base.css">
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <style>
        /* AMBA Template Styles */
        .dp-wrapper {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            line-height: 1.6;
            color: #2c3e50;
        }

        .dp-content-block {
            margin-bottom: 2rem;
        }

        .dp-has-icon {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            color: #034638;
            margin: 0 0 1rem 0;
        }

        .dp-card {
            background: white;
            border-radius: 8px;
            padding: 1.5rem;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            margin: 1rem 0;
        }

        .dp-card.intro-card {
            border-left: 4px solid #034638;
            background: #f8fffe;
        }
            color: #6b7280;
            margin-bottom: 30px;
            font-size: 1.1em;
        }

        .controls-section {
            background: #f8fafc;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 25px;
            border-left: 4px solid #582C83;
        }

        .control-group {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 15px;
            align-items: center;
        }

        .control-item {
            display: flex;
            flex-direction: column;
            min-width: 140px;
        }

        label {
            font-weight: 600;
            color: #374151;
            margin-bottom: 5px;
            font-size: 0.9em;
        }

        input[type="range"] {
            width: 140px;
            margin: 5px 0;
        }

        .value-display {
            font-weight: bold;
            color: #582C83;
            text-align: center;
            padding: 2px 8px;
            background: #f3f0ff;
            border-radius: 4px;
            font-size: 0.9em;
        }

        .training-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-top: 15px;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background: #582C83;
            color: white;
        }

        .btn-primary:hover {
            background: #4c1d95;
        }

        .btn-secondary {
            background: #034638;
            color: white;
        }

        .btn-secondary:hover {
            background: #0a5c4a;
        }

        .btn-reset {
            background: #dc2626;
            color: white;
        }

        .btn-reset:hover {
            background: #b91c1c;
        }

        .visualization-grid {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .plot-container {
            background: white;
            border-radius: 8px;
            border: 1px solid #e5e7eb;
            padding: 15px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .plot-title {
            font-weight: bold;
            color: #374151;
            margin-bottom: 10px;
            text-align: center;
        }

        .metrics-section {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .metric-card {
            background: #f8fafc;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            padding: 15px;
            text-align: center;
        }

        .metric-title {
            font-weight: bold;
            color: #6b7280;
            font-size: 0.9em;
            margin-bottom: 5px;
        }

        .metric-value {
            font-size: 1.6em;
            font-weight: bold;
            color: #034638;
        }

        .network-diagram {
            background: #faf5ff;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            border: 1px solid #e5e7eb;
        }

        .network-title {
            font-weight: bold;
            color: #582C83;
            margin-bottom: 15px;
            text-align: center;
        }

        .explanation-section {
            background: #f0f9ff;
            border-radius: 8px;
            padding: 20px;
            margin-top: 20px;
            border-left: 4px solid #3b82f6;
        }

        .explanation-title {
            font-weight: bold;
            color: #1e40af;
            margin-bottom: 10px;
        }

        .explanation-text {
            color: #1e3a8a;
            line-height: 1.6;
        }

        .epoch-display {
            font-size: 1.2em;
            font-weight: bold;
            color: #582C83;
            margin-left: 15px;
        }

        @media (max-width: 1024px) {
            .visualization-grid {
                grid-template-columns: 1fr 1fr;
            }
        }

        @media (max-width: 768px) {
            .visualization-grid {
                grid-template-columns: 1fr;
            }

            .control-group {
                flex-direction: column;
                align-items: stretch;
            }

            .training-controls {
                flex-direction: column;
                align-items: stretch;
            }
        }
    </style>
</head>
<body>
    <div class="dp-wrapper">
        <div class="dp-content-block">
            <h2 class="dp-has-icon">ðŸ§  Perceptron Playground</h2>
            <div class="dp-card intro-card">
                <p><strong>Interactive Learning:</strong> Explore how neural networks learn through interactive training. Adjust parameters and watch the perceptron adapt its decision boundary in real-time.</p>
            </div>
        </div>

        <div class="controls-section">
            <h3>Neural Network Configuration</h3>

            <div class="control-group">
                <div class="control-item">
                    <label for="learningRate">Learning Rate</label>
                    <input type="range" id="learningRate" min="0.01" max="1.0" value="0.1" step="0.01">
                    <div class="value-display" id="learningRateValue">0.10</div>
                </div>

                <div class="control-item">
                    <label for="dataPoints">Training Points</label>
                    <input type="range" id="dataPoints" min="50" max="300" value="150" step="25">
                    <div class="value-display" id="dataPointsValue">150</div>
                </div>

                <div class="control-item">
                    <label for="noiseLevel">Noise Level</label>
                    <input type="range" id="noiseLevel" min="0" max="0.3" value="0.1" step="0.05">
                    <div class="value-display" id="noiseLevelValue">0.10</div>
                </div>

                <div class="control-item">
                    <label for="batchSize">Batch Size</label>
                    <input type="range" id="batchSize" min="1" max="50" value="10" step="1">
                    <div class="value-display" id="batchSizeValue">10</div>
                </div>
            </div>

            <div class="training-controls">
                <button class="btn btn-primary" id="startTraining">Start Training</button>
                <button class="btn btn-secondary" id="stepTraining">Single Step</button>
                <button class="btn btn-reset" id="resetNetwork">Reset Network</button>
                <span class="epoch-display">Epoch: <span id="epochCount">0</span></span>
            </div>
        </div>

        <div class="visualization-grid">
            <div class="plot-container">
                <div class="plot-title">Training Data & Decision Boundary</div>
                <div id="dataPlot" style="height: 350px;"></div>
            </div>

            <div class="plot-container">
                <div class="plot-title">Loss Over Time</div>
                <div id="lossPlot" style="height: 350px;"></div>
            </div>

            <div class="plot-container">
                <div class="plot-title">Weight Evolution</div>
                <div id="weightPlot" style="height: 350px;"></div>
            </div>
        </div>

        <div class="network-diagram">
            <div class="network-title">Current Network State</div>
            <div id="networkDiagram" style="height: 200px;"></div>
        </div>

        <div class="metrics-section">
            <div class="metric-card">
                <div class="metric-title">Current Accuracy</div>
                <div class="metric-value" id="currentAccuracy">50.0%</div>
            </div>
            <div class="metric-card">
                <div class="metric-title">Current Loss</div>
                <div class="metric-value" id="currentLoss">0.693</div>
            </div>
            <div class="metric-card">
                <div class="metric-title">Weight W1</div>
                <div class="metric-value" id="weight1">0.00</div>
            </div>
            <div class="metric-card">
                <div class="metric-title">Weight W2</div>
                <div class="metric-value" id="weight2">0.00</div>
            </div>
            <div class="metric-card">
                <div class="metric-title">Bias</div>
                <div class="metric-value" id="bias">0.00</div>
            </div>
        </div>

        <div class="explanation-section">
            <div class="explanation-title">ðŸ§  How the Perceptron Learns</div>
            <div class="explanation-text" id="explanationText">
                The perceptron is the building block of neural networks. It takes two inputs (x1, x2), multiplies them by weights (w1, w2), adds a bias term, and passes the result through an activation function. During training, the weights are adjusted using gradient descent to minimize prediction errors.
            </div>
        </div>
    </div>

    <script>
        class Perceptron {
            constructor() {
                this.weights = [Math.random() * 0.1 - 0.05, Math.random() * 0.1 - 0.05];
                this.bias = Math.random() * 0.1 - 0.05;
                this.learningRate = 0.1;
                this.epoch = 0;
                this.lossHistory = [];
                this.weightHistory = [];
                this.accuracyHistory = [];
            }

            sigmoid(x) {
                return 1 / (1 + Math.exp(-Math.max(-500, Math.min(500, x))));
            }

            forward(x1, x2) {
                const z = this.weights[0] * x1 + this.weights[1] * x2 + this.bias;
                return this.sigmoid(z);
            }

            predict(x1, x2) {
                return this.forward(x1, x2) > 0.5 ? 1 : 0;
            }

            train(data, batchSize) {
                // Shuffle data
                const shuffled = [...data].sort(() => Math.random() - 0.5);

                let totalLoss = 0;
                let correct = 0;

                // Process in batches
                for (let i = 0; i < shuffled.length; i += batchSize) {
                    const batch = shuffled.slice(i, i + batchSize);
                    let batchGradW1 = 0, batchGradW2 = 0, batchGradB = 0;

                    for (let point of batch) {
                        const prediction = this.forward(point.x, point.y);
                        const error = point.label - prediction;

                        // Calculate gradients
                        batchGradW1 += error * prediction * (1 - prediction) * point.x;
                        batchGradW2 += error * prediction * (1 - prediction) * point.y;
                        batchGradB += error * prediction * (1 - prediction);

                        // Calculate loss and accuracy
                        totalLoss += -point.label * Math.log(prediction + 1e-15) - (1 - point.label) * Math.log(1 - prediction + 1e-15);
                        if (this.predict(point.x, point.y) === point.label) correct++;
                    }

                    // Update weights with averaged gradients
                    this.weights[0] += this.learningRate * batchGradW1 / batch.length;
                    this.weights[1] += this.learningRate * batchGradW2 / batch.length;
                    this.bias += this.learningRate * batchGradB / batch.length;
                }

                this.epoch++;
                const avgLoss = totalLoss / data.length;
                const accuracy = correct / data.length;

                this.lossHistory.push(avgLoss);
                this.accuracyHistory.push(accuracy);
                this.weightHistory.push([...this.weights, this.bias]);

                return { loss: avgLoss, accuracy: accuracy };
            }

            reset() {
                this.weights = [Math.random() * 0.1 - 0.05, Math.random() * 0.1 - 0.05];
                this.bias = Math.random() * 0.1 - 0.05;
                this.epoch = 0;
                this.lossHistory = [];
                this.weightHistory = [];
                this.accuracyHistory = [];
            }
        }

        // Global variables
        let perceptron = new Perceptron();
        let trainingData = [];
        let isTraining = false;
        let trainingInterval = null;

        // Generate training data
        function generateData(numPoints, noiseLevel) {
            const data = [];

            for (let i = 0; i < numPoints; i++) {
                const x = Math.random() * 4 - 2;
                const y = Math.random() * 4 - 2;

                // XOR-like pattern with noise
                let label = (x > 0) !== (y > 0) ? 1 : 0;

                // Add noise
                if (Math.random() < noiseLevel) {
                    label = 1 - label;
                }

                data.push({ x, y, label });
            }

            return data;
        }

        // Create decision boundary
        function createDecisionBoundary() {
            const resolution = 50;
            const range = 2.5;
            const step = (2 * range) / resolution;

            const x = [];
            const y = [];
            const z = [];

            for (let i = 0; i <= resolution; i++) {
                x.push(-range + i * step);
                const row = [];
                for (let j = 0; j <= resolution; j++) {
                    if (i === 0) y.push(-range + j * step);

                    const prediction = perceptron.forward(-range + i * step, -range + j * step);
                    row.push(prediction);
                }
                z.push(row);
            }

            return { x, y, z };
        }

        // Update visualizations
        function updateDataPlot() {
            const class0 = trainingData.filter(d => d.label === 0);
            const class1 = trainingData.filter(d => d.label === 1);
            const boundary = createDecisionBoundary();

            const traces = [
                {
                    x: boundary.x,
                    y: boundary.y,
                    z: boundary.z,
                    type: 'contour',
                    contours: {
                        coloring: 'fill',
                        showlabels: false
                    },
                    colorscale: [[0, 'rgba(220, 38, 38, 0.2)'], [1, 'rgba(34, 197, 94, 0.2)']],
                    showscale: false,
                    hoverinfo: 'skip'
                },
                {
                    x: class0.map(d => d.x),
                    y: class0.map(d => d.y),
                    mode: 'markers',
                    type: 'scatter',
                    name: 'Class 0',
                    marker: {
                        color: '#dc2626',
                        size: 8,
                        line: { color: 'white', width: 1 }
                    }
                },
                {
                    x: class1.map(d => d.x),
                    y: class1.map(d => d.y),
                    mode: 'markers',
                    type: 'scatter',
                    name: 'Class 1',
                    marker: {
                        color: '#16a34a',
                        size: 8,
                        line: { color: 'white', width: 1 }
                    }
                }
            ];

            const layout = {
                xaxis: { title: 'Feature X1', range: [-2.5, 2.5] },
                yaxis: { title: 'Feature X2', range: [-2.5, 2.5] },
                margin: { l: 50, r: 20, t: 40, b: 50 },
                showlegend: true,
                legend: { x: 0.02, y: 0.98 }
            };

            Plotly.newPlot('dataPlot', traces, layout, { responsive: true });
        }

        function updateLossPlot() {
            if (perceptron.lossHistory.length === 0) return;

            const trace = {
                x: Array.from({ length: perceptron.lossHistory.length }, (_, i) => i + 1),
                y: perceptron.lossHistory,
                type: 'scatter',
                mode: 'lines',
                line: { color: '#582C83', width: 2 },
                name: 'Training Loss'
            };

            const layout = {
                xaxis: { title: 'Epoch' },
                yaxis: { title: 'Loss' },
                margin: { l: 50, r: 20, t: 40, b: 50 },
                showlegend: false
            };

            Plotly.newPlot('lossPlot', [trace], layout, { responsive: true });
        }

        function updateWeightPlot() {
            if (perceptron.weightHistory.length === 0) return;

            const w1History = perceptron.weightHistory.map(w => w[0]);
            const w2History = perceptron.weightHistory.map(w => w[1]);
            const biasHistory = perceptron.weightHistory.map(w => w[2]);
            const epochs = Array.from({ length: w1History.length }, (_, i) => i + 1);

            const traces = [
                {
                    x: epochs,
                    y: w1History,
                    type: 'scatter',
                    mode: 'lines',
                    name: 'Weight 1',
                    line: { color: '#3b82f6', width: 2 }
                },
                {
                    x: epochs,
                    y: w2History,
                    type: 'scatter',
                    mode: 'lines',
                    name: 'Weight 2',
                    line: { color: '#ef4444', width: 2 }
                },
                {
                    x: epochs,
                    y: biasHistory,
                    type: 'scatter',
                    mode: 'lines',
                    name: 'Bias',
                    line: { color: '#10b981', width: 2 }
                }
            ];

            const layout = {
                xaxis: { title: 'Epoch' },
                yaxis: { title: 'Value' },
                margin: { l: 50, r: 20, t: 40, b: 50 },
                showlegend: true,
                legend: { x: 0.02, y: 0.98 }
            };

            Plotly.newPlot('weightPlot', traces, layout, { responsive: true });
        }

        function updateNetworkDiagram() {
            const traces = [
                // Input nodes
                {
                    x: [0.2, 0.2],
                    y: [0.7, 0.3],
                    mode: 'markers+text',
                    type: 'scatter',
                    marker: { size: 40, color: '#3b82f6' },
                    text: ['X1', 'X2'],
                    textposition: 'middle center',
                    textfont: { color: 'white', size: 12 },
                    showlegend: false,
                    hoverinfo: 'skip'
                },
                // Output node
                {
                    x: [0.8],
                    y: [0.5],
                    mode: 'markers+text',
                    type: 'scatter',
                    marker: { size: 40, color: '#16a34a' },
                    text: ['Output'],
                    textposition: 'middle center',
                    textfont: { color: 'white', size: 10 },
                    showlegend: false,
                    hoverinfo: 'skip'
                },
                // Connections
                {
                    x: [0.2, 0.8, null, 0.2, 0.8],
                    y: [0.7, 0.5, null, 0.3, 0.5],
                    mode: 'lines',
                    type: 'scatter',
                    line: { color: '#6b7280', width: 2 },
                    showlegend: false,
                    hoverinfo: 'skip'
                }
            ];

            const layout = {
                xaxis: { range: [0, 1], showgrid: false, showticklabels: false },
                yaxis: { range: [0, 1], showgrid: false, showticklabels: false },
                margin: { l: 20, r: 20, t: 20, b: 20 },
                showlegend: false,
                annotations: [
                    {
                        x: 0.5, y: 0.65,
                        text: `w1=${perceptron.weights[0].toFixed(2)}`,
                        showarrow: false,
                        font: { size: 10 }
                    },
                    {
                        x: 0.5, y: 0.35,
                        text: `w2=${perceptron.weights[1].toFixed(2)}`,
                        showarrow: false,
                        font: { size: 10 }
                    },
                    {
                        x: 0.5, y: 0.15,
                        text: `bias=${perceptron.bias.toFixed(2)}`,
                        showarrow: false,
                        font: { size: 10 }
                    }
                ]
            };

            Plotly.newPlot('networkDiagram', traces, layout, { responsive: true });
        }

        function updateMetrics() {
            if (perceptron.accuracyHistory.length > 0) {
                const currentAccuracy = perceptron.accuracyHistory[perceptron.accuracyHistory.length - 1];
                document.getElementById('currentAccuracy').textContent = `${(currentAccuracy * 100).toFixed(1)}%`;
            } else {
                document.getElementById('currentAccuracy').textContent = '50.0%';
            }

            if (perceptron.lossHistory.length > 0) {
                const currentLoss = perceptron.lossHistory[perceptron.lossHistory.length - 1];
                document.getElementById('currentLoss').textContent = currentLoss.toFixed(3);
            } else {
                document.getElementById('currentLoss').textContent = '0.693';
            }

            document.getElementById('weight1').textContent = perceptron.weights[0].toFixed(2);
            document.getElementById('weight2').textContent = perceptron.weights[1].toFixed(2);
            document.getElementById('bias').textContent = perceptron.bias.toFixed(2);
            document.getElementById('epochCount').textContent = perceptron.epoch;
        }

        function updateExplanation() {
            const accuracy = perceptron.accuracyHistory.length > 0 ?
                perceptron.accuracyHistory[perceptron.accuracyHistory.length - 1] : 0.5;

            let phase = "initialization";
            if (perceptron.epoch > 50) phase = "convergence";
            else if (perceptron.epoch > 10) phase = "learning";
            else if (perceptron.epoch > 0) phase = "early training";

            const explanations = {
                initialization: "The perceptron starts with random weights. It will learn by adjusting these weights based on prediction errors.",
                "early training": "The network is making initial weight adjustments. Large changes in loss are normal as it explores the solution space.",
                learning: "The perceptron is actively learning patterns in the data. Watch how the decision boundary evolves with each epoch.",
                convergence: "The network is converging to a stable solution. Weight changes become smaller as learning stabilizes."
            };

            document.getElementById('explanationText').textContent =
                `${explanations[phase]} Current accuracy: ${(accuracy * 100).toFixed(1)}%. ` +
                `The sigmoid activation function ensures outputs stay between 0 and 1, representing probabilities.`;
        }

        function initializeData() {
            const numPoints = parseInt(document.getElementById('dataPoints').value);
            const noiseLevel = parseFloat(document.getElementById('noiseLevel').value);
            trainingData = generateData(numPoints, noiseLevel);
        }

        function updateVisualization() {
            updateDataPlot();
            updateLossPlot();
            updateWeightPlot();
            updateNetworkDiagram();
            updateMetrics();
            updateExplanation();
        }

        function trainStep() {
            const batchSize = parseInt(document.getElementById('batchSize').value);
            perceptron.learningRate = parseFloat(document.getElementById('learningRate').value);

            const result = perceptron.train(trainingData, batchSize);
            updateVisualization();

            return result;
        }

        // Event listeners
        document.getElementById('startTraining').addEventListener('click', () => {
            if (!isTraining) {
                isTraining = true;
                document.getElementById('startTraining').textContent = 'Stop Training';

                trainingInterval = setInterval(() => {
                    const result = trainStep();

                    // Stop if converged
                    if (perceptron.epoch > 100 && result.loss < 0.01) {
                        document.getElementById('startTraining').click();
                    }
                }, 100);
            } else {
                isTraining = false;
                document.getElementById('startTraining').textContent = 'Start Training';
                clearInterval(trainingInterval);
            }
        });

        document.getElementById('stepTraining').addEventListener('click', trainStep);

        document.getElementById('resetNetwork').addEventListener('click', () => {
            if (isTraining) {
                document.getElementById('startTraining').click();
            }

            perceptron.reset();
            initializeData();
            updateVisualization();
        });

        // Parameter change listeners
        document.getElementById('learningRate').addEventListener('input', (e) => {
            document.getElementById('learningRateValue').textContent = parseFloat(e.target.value).toFixed(2);
        });

        document.getElementById('dataPoints').addEventListener('input', (e) => {
            document.getElementById('dataPointsValue').textContent = e.target.value;
            if (!isTraining) {
                initializeData();
                updateDataPlot();
            }
        });

        document.getElementById('noiseLevel').addEventListener('input', (e) => {
            document.getElementById('noiseLevelValue').textContent = parseFloat(e.target.value).toFixed(2);
            if (!isTraining) {
                initializeData();
                updateDataPlot();
            }
        });

        document.getElementById('batchSize').addEventListener('input', (e) => {
            document.getElementById('batchSizeValue').textContent = e.target.value;
        });

        // Initialize
        initializeData();
        updateVisualization();
    </script>
</body>
</html>